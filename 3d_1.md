# 3D Engine , Part 1

##  Triangles & Projection

- I'm going to suggest that all of our dots are grouped into triangles
    - any 2D primitive can be represented using nothing but triangles
- Finally when it comes to drawing triangles on a screen there are some very optimized algorithms to do this, because a triangle consists of straight lines.
    - and there are also some neat algorithms to fill in a triangle and shade it on the screen, again using straight horizontal lines.

![](imgs/3d_0.png)

- There is somethign important about the triangles, the order of the vertices we define the triangle. 
    - I want to always use a clockwise order.
    - ![](imgs/3d_1.png)
    - exactly the same for the remaining faces.

## Projection 

let's define our screen.

Because screens come in all shapes and sizes, it's useful to reduce the 3D objects into a normalized screen space. 

- ![](imgs/3d_2.png)

And because the width and height can be different we want to scale movements within the screen space accordingly.  So we are going to use the **aspect ratio**.

aspect ratio:  a = h/w.   This will be the first of serveral assumptions about how we're going to transform our 3D vector [x,y,z] into our screen space vector [(h/w)x,y,z].

Normalizeing the screen space has an additional advantage that anything above +1 or below -1 definitely won't be drawn to screen. 

- ![](imgs/3d_3.png)

However humans don't see screens in that manner they see instead what's called **the field of view**. Objects that are further away we can see more space.

If the field of view is particulary narrow (see that blue 1) it has the effect that zooming in on the object. And if the field of view goes wide, it has the effect of zooming out, we see more stuff. 

- ![](imgs/3d_4.png)

And this means we need a scaling factor that relates to the field of view, **θ**. One way to think about the scaling factor is to draw a right triangle right down the middle of our field of view. 

- ![](imgs/3d_5.png)

And as this angle ( θ/2 ) increases,  our opposite side of the triangle increases.  We might want to consider looking at the tangent function tan(θ/2).

But there's a slight problem here if we take a point and we increase our field of view, the scaling factor tan(θ/2) get larger.  But actually when we increase FOV, we should have the effect of zooming out.

So what we want is the exact opposite of this. Indeed we want the inverse

```
1 / tan(θ/2)
```

This gives us some more coefficients to add to our transforamtion `[x,y,z]->[(h/w)Fx,Fy,z]`  , where F = `1 / tan(θ/2)`

Since we've gone to the trouble of normalizing x and y. And realistically all we're interested is in x and y because this is a 2D surface in the end. 

We may as well also attempt to normalize z, and the reason for this might not be immediately apparent. But knowing what z is in the same space as x and y can be really useful for optimizing our algorithms and handling other interesting drawing routines like transparency in depth.



 



